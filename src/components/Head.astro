---
import "../styles/global.css";
import "@fontsource/monaspace-neon/latin-400.css";
import "@fontsource/monaspace-neon/latin-600.css";
import "@fontsource/inter/latin-400.css";
import "@fontsource/inter/latin-500.css";
import "@fontsource/inter/latin-600.css";
import mono400 from "@fontsource/monaspace-neon/files/monaspace-neon-latin-400-normal.woff2";
import mono600 from "@fontsource/monaspace-neon/files/monaspace-neon-latin-600-normal.woff2";
import sans400 from "@fontsource/inter/files/inter-latin-400-normal.woff2";
import sans600 from "@fontsource/inter/files/inter-latin-600-normal.woff2";

import { ClientRouter } from "astro:transitions";
import { SITE } from "@consts";

interface Props {
  title: string;
  description: string;
  image?: string;
}

const canonicalURL = new URL(Astro.url.pathname, Astro.site);

const { title, description, image = "/nano.png" } = Astro.props;
---

<!-- Global Metadata -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link
  rel="icon"
  type="image/svg+xml"
  href="/favicon-dark.svg"
  media="(prefers-color-scheme: dark)"
/>
<link
  rel="icon"
  type="image/svg+xml"
  href="/favicon-light.svg"
  media="(prefers-color-scheme: light)"
/>
<link rel="icon" type="image/x-icon" href="/favicon-dark.svg" />
<meta name="generator" content={Astro.generator} />

<!-- Font preloads -->
<link rel="preload" href={mono400} as="font" type="font/woff2" crossorigin />
<link rel="preload" href={mono600} as="font" type="font/woff2" crossorigin />
<link rel="preload" href={sans400} as="font" type="font/woff2" crossorigin />
<link rel="preload" href={sans600} as="font" type="font/woff2" crossorigin />

<!-- Canonical URL -->
<link rel="canonical" href={canonicalURL} />

<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} />

<ClientRouter />

<!-- RSS Link -->
<link
  rel="alternate"
  type="application/rss+xml"
  title={SITE.NAME}
  href={new URL("rss.xml", Astro.site)}
/>

<!-- Theme preload — must run synchronously before body renders to prevent flash -->
<script is:inline>
  (function () {
    const savedTheme = localStorage.getItem("theme");
    const prefersDark = window.matchMedia(
      "(prefers-color-scheme: dark)",
    ).matches;
    const shouldBeDark =
      savedTheme === "dark" || (savedTheme !== "light" && prefersDark);
    document.documentElement.classList.toggle("dark", shouldBeDark);
  })();
</script>

<!--
  Main site script — bundled module that runs once and never re-executes on
  navigation. Uses astro:page-load for per-navigation setup and event
  delegation on document for persistent listeners. Imports i18n data directly
  instead of define:vars.
-->
<script>
  import type { TransitionBeforeSwapEvent } from "astro:transitions/client";
  import { greetings, greetingColorCount, pages } from "@i18n/en";

  // ---------------------------------------------------------------------------
  // Constants
  // ---------------------------------------------------------------------------

  const STAGGER_DELAY_MS = 150;
  const TYPEWRITER_TYPE_SPEED_MS = 100;
  const TYPEWRITER_DELETE_SPEED_MS = 60;
  const TYPEWRITER_PAUSE_BEFORE_DELETE_MS = 2500;
  const TYPEWRITER_PAUSE_AFTER_DELETE_MS = 150;

  const PAGE_DESCRIPTIONS: Record<string, string> = {
    "/about": pages.about.description,
    "/blog": pages.blog.description,
    "/projects": pages.projects.description,
    "/shelf": pages.shelf.description,
  };

  let isFirstLoad = true;
  let typewriterTimeoutId: number | null = null;

  // ---------------------------------------------------------------------------
  // Chrome listeners — registered once at module load, use event delegation
  // ---------------------------------------------------------------------------

  // Click delegation: theme buttons, mobile menu toggle, back-to-top
  document.addEventListener("click", (clickEvent) => {
    const clickTarget = clickEvent.target as HTMLElement;

    const themeButton = clickTarget.closest("[data-theme-button]");
    if (themeButton instanceof HTMLElement) {
      const selectedTheme = themeButton.dataset.themeButton;
      if (selectedTheme) {
        localStorage.setItem("theme", selectedTheme);
        if (selectedTheme === "light") {
          applyTheme(false);
        } else if (selectedTheme === "dark") {
          applyTheme(true);
        } else {
          applyTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
        }
        updateThemeButtons();
      }
      return;
    }

    const menuToggleButton = clickTarget.closest("#menu-toggle");
    if (menuToggleButton instanceof HTMLElement) {
      const mobileMenu = document.getElementById("mobile-menu");
      const menuOpenIcon = document.getElementById("menu-open-icon");
      const menuCloseIcon = document.getElementById("menu-close-icon");
      if (mobileMenu && menuOpenIcon && menuCloseIcon) {
        mobileMenu.classList.toggle("hidden");
        menuOpenIcon.classList.toggle("hidden");
        menuCloseIcon.classList.toggle("hidden");
        const isExpanded = !mobileMenu.classList.contains("hidden");
        menuToggleButton.setAttribute(
          "aria-expanded",
          isExpanded ? "true" : "false",
        );
      }
      return;
    }

    if (clickTarget.closest("#back-to-top")) {
      clickEvent.preventDefault();
      window.scrollTo({ top: 0, behavior: "smooth" });
    }
  });

  // Nav link hover taglines (desktop only)
  document.addEventListener("mouseover", (mouseOverEvent) => {
    const hoveredNavLink = (mouseOverEvent.target as HTMLElement).closest(
      "header nav a",
    );
    if (!hoveredNavLink) return;

    const hoveredPath =
      (hoveredNavLink.getAttribute("href") ?? "").replace(/\/$/, "") || "/";
    const hoveredDescription = PAGE_DESCRIPTIONS[hoveredPath];
    if (!hoveredDescription) return;

    const taglineElement = document.getElementById("nav-tagline");
    if (!taglineElement) return;

    taglineElement.textContent = hoveredDescription;
    taglineElement.style.left =
      hoveredNavLink.getBoundingClientRect().left + "px";
    taglineElement.classList.remove("hidden");
  });

  document.addEventListener("mouseout", (mouseOutEvent) => {
    if (!(mouseOutEvent.target as HTMLElement).closest("header nav a")) return;
    const taglineElement = document.getElementById("nav-tagline");
    if (taglineElement) taglineElement.classList.add("hidden");
  });

  // System theme preference changes
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (mediaChangeEvent) => {
      if (localStorage.getItem("theme") === "system") {
        applyTheme(mediaChangeEvent.matches);
      }
    });

  // Scroll state
  document.addEventListener("scroll", handleScroll);

  // ---------------------------------------------------------------------------
  // View Transition — prepare new document before swap
  // ---------------------------------------------------------------------------

  document.addEventListener("astro:before-swap", (swapEvent) => {
    const transitionEvent = swapEvent as TransitionBeforeSwapEvent;

    // Remove duplicate font links from new document
    [
      ...transitionEvent.newDocument.head.querySelectorAll('link[as="font"]'),
    ].forEach((fontLink) => fontLink.remove());

    // Apply theme to new document before swap to prevent flash
    const savedTheme = localStorage.getItem("theme");
    const prefersDarkMode = window.matchMedia(
      "(prefers-color-scheme: dark)",
    ).matches;
    const shouldBeDark =
      savedTheme === "dark" || (savedTheme !== "light" && prefersDarkMode);
    if (shouldBeDark) {
      transitionEvent.newDocument.documentElement.classList.add("dark");
    } else {
      transitionEvent.newDocument.documentElement.classList.remove("dark");
    }
  });

  // ---------------------------------------------------------------------------
  // Per-navigation setup — runs on initial load AND each navigation
  // ---------------------------------------------------------------------------

  function onPageLoad(): void {
    applyTheme(shouldBeDark());
    updateThemeButtons();
    handleScroll();
    revealAnimatedElements(isFirstLoad ? STAGGER_DELAY_MS : 0);
    isFirstLoad = false;

    resetMobileMenu();
    updateActiveNavLink();
    setupTypewriter();
    setupFooter();
  }

  document.addEventListener("astro:page-load", onPageLoad);

  // ---------------------------------------------------------------------------
  // Mobile menu reset
  // ---------------------------------------------------------------------------

  function resetMobileMenu(): void {
    const mobileMenu = document.getElementById("mobile-menu");
    if (mobileMenu) mobileMenu.classList.add("hidden");
    const menuOpenIcon = document.getElementById("menu-open-icon");
    const menuCloseIcon = document.getElementById("menu-close-icon");
    if (menuOpenIcon) menuOpenIcon.classList.remove("hidden");
    if (menuCloseIcon) menuCloseIcon.classList.add("hidden");
    const menuToggleButton = document.getElementById("menu-toggle");
    if (menuToggleButton) {
      menuToggleButton.setAttribute("aria-expanded", "false");
    }
  }

  // ---------------------------------------------------------------------------
  // Active nav highlighting
  // ---------------------------------------------------------------------------

  function updateActiveNavLink(): void {
    const currentPath = window.location.pathname.replace(/\/$/, "") || "/";
    const navLinks = document.querySelectorAll("header nav a");

    navLinks.forEach((navLink) => {
      const linkPath =
        (navLink.getAttribute("href") ?? "").replace(/\/$/, "") || "/";
      if (
        currentPath === linkPath ||
        (linkPath !== "/" && currentPath.startsWith(linkPath + "/"))
      ) {
        navLink.classList.add("nav-active");
      } else {
        navLink.classList.remove("nav-active");
      }
    });

    const homeNavLink = document.getElementById("nav-home");
    if (homeNavLink) {
      if (currentPath === "/") {
        homeNavLink.classList.add("nav-active");
      } else {
        homeNavLink.classList.remove("nav-active");
      }
    }
  }

  // ---------------------------------------------------------------------------
  // Typewriter greeting
  //
  // Types, pauses, deletes, and retypes greetings in different languages.
  // Each greeting gets a random color from the palette (never same twice).
  // Cursor blinks when idle, stays solid when typing/deleting.
  // ---------------------------------------------------------------------------

  function setupTypewriter(): void {
    if (typewriterTimeoutId !== null) {
      clearTimeout(typewriterTimeoutId);
      typewriterTimeoutId = null;
    }

    // Early exit if the greeting elements aren't on this page
    if (
      !document.getElementById("greeting") ||
      !document.getElementById("typewriter-cursor") ||
      !document.getElementById("greeting-wrapper")
    )
      return;

    // Re-fetch as non-nullable consts so closures below see HTMLElement, not
    // HTMLElement | null (TypeScript doesn't narrow captured variables).
    const greetingElement = document.getElementById("greeting") as HTMLElement;
    const cursorElement = document.getElementById(
      "typewriter-cursor",
    ) as HTMLElement;
    const wrapperElement = document.getElementById(
      "greeting-wrapper",
    ) as HTMLElement;

    // Skip animation entirely for users who prefer reduced motion
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) {
      greetingElement.textContent = greetings[0];
      cursorElement.classList.remove("cursor-blink");
      return;
    }

    let greetingIndex = 0;
    let characterIndex = greetings[0].length;
    let isDeleting = false;
    let activeColorIndex = 0;

    function pickNextColor(): void {
      let nextColorIndex: number;
      do {
        nextColorIndex = Math.floor(Math.random() * greetingColorCount);
      } while (nextColorIndex === activeColorIndex);
      activeColorIndex = nextColorIndex;
      wrapperElement.style.color = `var(--greeting-color-${nextColorIndex})`;
      greetingElement.style.backgroundImage = `var(--greeting-grad-${nextColorIndex})`;
    }

    function typewriterTick(): void {
      const currentGreeting = greetings[greetingIndex];
      cursorElement.classList.add("cursor-typing");

      if (isDeleting) {
        characterIndex--;
        greetingElement.textContent = currentGreeting.substring(
          0,
          characterIndex,
        );

        if (characterIndex === 0) {
          isDeleting = false;
          greetingIndex = (greetingIndex + 1) % greetings.length;
          pickNextColor();
          typewriterTimeoutId = window.setTimeout(
            typewriterTick,
            TYPEWRITER_PAUSE_AFTER_DELETE_MS,
          );
        } else {
          typewriterTimeoutId = window.setTimeout(
            typewriterTick,
            TYPEWRITER_DELETE_SPEED_MS,
          );
        }
      } else {
        characterIndex++;
        greetingElement.textContent = greetings[greetingIndex].substring(
          0,
          characterIndex,
        );

        if (characterIndex === greetings[greetingIndex].length) {
          cursorElement.classList.remove("cursor-typing");
          typewriterTimeoutId = window.setTimeout(() => {
            isDeleting = true;
            typewriterTick();
          }, TYPEWRITER_PAUSE_BEFORE_DELETE_MS);
        } else {
          typewriterTimeoutId = window.setTimeout(
            typewriterTick,
            TYPEWRITER_TYPE_SPEED_MS,
          );
        }
      }
    }

    // Start with first greeting visible, cursor blinking. After pause, cycle.
    typewriterTimeoutId = window.setTimeout(() => {
      isDeleting = true;
      typewriterTick();
    }, TYPEWRITER_PAUSE_BEFORE_DELETE_MS);
  }

  // ---------------------------------------------------------------------------
  // Footer — dynamic year
  // ---------------------------------------------------------------------------

  function setupFooter(): void {
    const footerYearElement = document.getElementById("footer-year");
    if (footerYearElement) {
      footerYearElement.textContent = new Date().getFullYear().toString();
    }
  }

  // ---------------------------------------------------------------------------
  // Stagger animation — reveals .animate elements sequentially on first load
  // ---------------------------------------------------------------------------

  function revealAnimatedElements(delayBetweenMs: number): void {
    const animatedElements = document.querySelectorAll(".animate");

    animatedElements.forEach((element, index) => {
      if (delayBetweenMs > 0) {
        setTimeout(() => {
          element.classList.add("show");
        }, index * delayBetweenMs);
      } else {
        element.classList.add("show");
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Scroll state
  // ---------------------------------------------------------------------------

  function handleScroll(): void {
    if (window.scrollY > 0) {
      document.documentElement.classList.add("scrolled");
    } else {
      document.documentElement.classList.remove("scrolled");
    }
  }

  // ---------------------------------------------------------------------------
  // Theme
  // ---------------------------------------------------------------------------

  function shouldBeDark(): boolean {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme === "light") return false;
    if (savedTheme === "dark") return true;
    return window.matchMedia("(prefers-color-scheme: dark)").matches;
  }

  function applyTheme(dark: boolean): void {
    // Temporarily disable transitions to prevent flash during theme switch
    const transitionBlocker = document.createElement("style");
    transitionBlocker.appendChild(
      document.createTextNode(
        "* {" +
          "-webkit-transition: none !important;" +
          "-moz-transition: none !important;" +
          "-o-transition: none !important;" +
          "-ms-transition: none !important;" +
          "transition: none !important;" +
          "}",
      ),
    );
    document.head.appendChild(transitionBlocker);

    document.documentElement.classList.toggle("dark", dark);

    // Force reflow so the transition blocker takes effect before removal
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    window.getComputedStyle(transitionBlocker).opacity;
    document.head.removeChild(transitionBlocker);
  }

  function updateThemeButtons(): void {
    const activeTheme = localStorage.getItem("theme") ?? "system";
    const themeButtons = document.querySelectorAll("[data-theme-button]");
    themeButtons.forEach((button) => {
      const isActive =
        (button as HTMLElement).dataset.themeButton === activeTheme;
      button.setAttribute("aria-pressed", isActive ? "true" : "false");
      if (isActive) {
        button.classList.add("theme-active");
      } else {
        button.classList.remove("theme-active");
      }
    });
  }
</script>
