---
import "../styles/global.css";
import "@fontsource/monaspace-neon/latin-400.css";
import "@fontsource/monaspace-neon/latin-600.css";
import "@fontsource/inter/latin-400.css";
import "@fontsource/inter/latin-500.css";
import "@fontsource/inter/latin-600.css";
import mono400 from "@fontsource/monaspace-neon/files/monaspace-neon-latin-400-normal.woff2";
import mono600 from "@fontsource/monaspace-neon/files/monaspace-neon-latin-600-normal.woff2";
import sans400 from "@fontsource/inter/files/inter-latin-400-normal.woff2";
import sans600 from "@fontsource/inter/files/inter-latin-600-normal.woff2";

import { ClientRouter } from "astro:transitions";
import { SITE } from "@consts";

interface Props {
  title: string;
  description: string;
  image?: string;
}

const canonicalURL = new URL(Astro.url.pathname, Astro.site);

const { title, description, image = "/og.png" } = Astro.props;
---

<!-- Global Metadata -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<meta name="generator" content={Astro.generator} />

<!-- Font preloads -->
<link rel="preload" href={mono400} as="font" type="font/woff2" crossorigin />
<link rel="preload" href={mono600} as="font" type="font/woff2" crossorigin />
<link rel="preload" href={sans400} as="font" type="font/woff2" crossorigin />
<link rel="preload" href={sans600} as="font" type="font/woff2" crossorigin />

<!-- Canonical URL -->
<link rel="canonical" href={canonicalURL} />

<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} />

<ClientRouter />

<!-- RSS Link -->
<link
  rel="alternate"
  type="application/rss+xml"
  title={SITE.NAME}
  href={new URL("rss.xml", Astro.site)}
/>

<!-- Theme + color scheme preload — must run synchronously before body renders to prevent flash -->
<script is:inline>
  (function () {
    const savedTheme = localStorage.getItem("theme");
    const prefersDark = window.matchMedia(
      "(prefers-color-scheme: dark)",
    ).matches;
    const shouldBeDark =
      savedTheme === "dark" || (savedTheme !== "light" && prefersDark);
    document.documentElement.classList.toggle("dark", shouldBeDark);

    const savedScheme = localStorage.getItem("colorScheme");
    document.documentElement.setAttribute(
      "data-color-scheme",
      savedScheme || "tokyo-night",
    );
  })();
</script>

<!--
  Main site script — bundled module that runs once and never re-executes on
  navigation. Uses astro:page-load for per-navigation setup and event
  delegation on document for persistent listeners. Imports i18n data directly
  instead of define:vars.
-->
<script>
  import type { TransitionBeforeSwapEvent } from "astro:transitions/client";
  import { greetings, greetingColorCount, pages } from "@i18n/en";

  // ---------------------------------------------------------------------------
  // Constants
  // ---------------------------------------------------------------------------

  const STAGGER_DELAY_MS = 150;
  const TYPEWRITER_TYPE_SPEED_MS = 100;
  const TYPEWRITER_DELETE_SPEED_MS = 60;
  const TYPEWRITER_PAUSE_BEFORE_DELETE_MS = 2500;
  const TYPEWRITER_PAUSE_AFTER_DELETE_MS = 150;
  const DEFAULT_COLOR_SCHEME = "tokyo-night";
  const TAGLINE_INSET_PX = 48;

  const PAGE_DESCRIPTIONS: Record<string, string> = {
    "/about": pages.about.description,
    "/blog": pages.blog.description,
    "/projects": pages.projects.description,
    "/shelf": pages.shelf.description,
  };

  let isFirstLoad = true;
  let typewriterTimeoutId: number | null = null;

  // ---------------------------------------------------------------------------
  // Chrome listeners — registered once at module load, use event delegation
  // ---------------------------------------------------------------------------

  // Click delegation: settings panel, theme buttons, color scheme buttons,
  // mobile menu toggle, back-to-top
  document.addEventListener("click", (clickEvent) => {
    const clickTarget = clickEvent.target as HTMLElement;

    // Settings panel trigger — toggle the panel that contains this trigger
    const settingsTrigger = clickTarget.closest("[data-settings-trigger]");
    if (settingsTrigger instanceof HTMLElement) {
      const settingsRoot = settingsTrigger.closest("[data-settings-root]");
      const settingsPanel = settingsRoot?.querySelector(
        "[data-settings-panel]",
      );
      if (settingsPanel) {
        const isOpen = !settingsPanel.classList.contains("hidden");
        // Close all open panels first (handles the case where both mobile and
        // desktop panels exist, e.g. during resize)
        closeAllSettingsPanels();
        if (!isOpen) {
          settingsPanel.classList.remove("hidden");
          settingsTrigger.setAttribute("aria-expanded", "true");
        }
      }
      return;
    }

    // Clicks inside a settings panel should not close it
    if (clickTarget.closest("[data-settings-panel]")) {
      // Fall through to theme/scheme button handlers below
    } else {
      // Click outside any settings panel — close all
      closeAllSettingsPanels();
    }

    const themeButton = clickTarget.closest("[data-theme-button]");
    if (themeButton instanceof HTMLElement) {
      const selectedTheme = themeButton.dataset.themeButton;
      if (selectedTheme) {
        localStorage.setItem("theme", selectedTheme);
        if (selectedTheme === "light") {
          applyTheme(false);
        } else if (selectedTheme === "dark") {
          applyTheme(true);
        } else {
          applyTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
        }
        updateThemeButtons();
      }
      return;
    }

    const schemeButton = clickTarget.closest("[data-scheme-button]");
    if (schemeButton instanceof HTMLElement) {
      const selectedScheme = schemeButton.dataset.schemeButton;
      if (selectedScheme) {
        localStorage.setItem("colorScheme", selectedScheme);
        document.documentElement.setAttribute(
          "data-color-scheme",
          selectedScheme,
        );
        updateColorSchemeButtons();
      }
      return;
    }

    const menuToggleButton = clickTarget.closest("#menu-toggle");
    if (menuToggleButton instanceof HTMLElement) {
      const mobileMenu = document.getElementById("mobile-menu");
      const menuOpenIcon = document.getElementById("menu-open-icon");
      const menuCloseIcon = document.getElementById("menu-close-icon");
      if (mobileMenu && menuOpenIcon && menuCloseIcon) {
        mobileMenu.classList.toggle("hidden");
        menuOpenIcon.classList.toggle("hidden");
        menuCloseIcon.classList.toggle("hidden");
        const isExpanded = !mobileMenu.classList.contains("hidden");
        menuToggleButton.setAttribute(
          "aria-expanded",
          isExpanded ? "true" : "false",
        );
      }
      return;
    }

    if (clickTarget.closest("#back-to-top")) {
      clickEvent.preventDefault();
      window.scrollTo({ top: 0, behavior: "smooth" });
    }
  });

  // Close settings panel on Escape
  document.addEventListener("keydown", (keyboardEvent) => {
    if (keyboardEvent.key === "Escape") {
      closeAllSettingsPanels();
    }
  });

  // Nav link hover taglines (desktop only, skip on touch devices)
  let hasTouchInput = false;
  document.addEventListener(
    "touchstart",
    () => {
      hasTouchInput = true;
    },
    { once: true },
  );

  document.addEventListener("mouseover", (mouseOverEvent) => {
    if (hasTouchInput) return;

    const hoveredNavLink = (mouseOverEvent.target as HTMLElement).closest(
      "header nav a",
    );
    if (!hoveredNavLink) return;

    const hoveredPath =
      (hoveredNavLink.getAttribute("href") ?? "").replace(/\/$/, "") || "/";
    const hoveredDescription = PAGE_DESCRIPTIONS[hoveredPath];
    if (!hoveredDescription) return;

    const taglineElement = document.getElementById("nav-tagline");
    if (!taglineElement) return;

    taglineElement.textContent = hoveredDescription;

    // Position aligned with hovered link. The tagline is position:absolute
    // inside its offset parent (the Container), so convert viewport coords
    // to parent-relative coords.
    const parentLeft =
      taglineElement.offsetParent?.getBoundingClientRect().left ?? 0;
    const linkLeft = hoveredNavLink.getBoundingClientRect().left;
    taglineElement.style.left = linkLeft - parentLeft + "px";
    taglineElement.classList.remove("hidden");

    // Clamp so the tagline doesn't overflow the offset parent's right edge
    const taglineRect = taglineElement.getBoundingClientRect();
    const parentRight =
      (taglineElement.offsetParent?.getBoundingClientRect().right ??
        window.innerWidth) - TAGLINE_INSET_PX;
    if (taglineRect.right > parentRight) {
      taglineElement.style.left =
        parentRight - parentLeft - taglineRect.width + "px";
    }
  });

  document.addEventListener("mouseout", (mouseOutEvent) => {
    if (!(mouseOutEvent.target as HTMLElement).closest("header nav a")) return;
    const taglineElement = document.getElementById("nav-tagline");
    if (taglineElement) taglineElement.classList.add("hidden");
  });

  // System theme preference changes
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (mediaChangeEvent) => {
      if (localStorage.getItem("theme") === "system") {
        applyTheme(mediaChangeEvent.matches);
      }
    });

  // Scroll state
  document.addEventListener("scroll", handleScroll);

  // ---------------------------------------------------------------------------
  // View Transition — prepare new document before swap
  // ---------------------------------------------------------------------------

  document.addEventListener("astro:before-swap", (swapEvent) => {
    const transitionEvent = swapEvent as TransitionBeforeSwapEvent;

    // Remove duplicate font links from new document
    [
      ...transitionEvent.newDocument.head.querySelectorAll('link[as="font"]'),
    ].forEach((fontLink) => fontLink.remove());

    // Pre-reveal animated elements so they're at final opacity/position when
    // the View Transition captures the new page snapshot. Without this, the
    // .animate class leaves elements at opacity:0 + translate-y:3, creating a
    // gap between the transition fade-in and content appearing.
    transitionEvent.newDocument
      .querySelectorAll(".animate")
      .forEach((element) => element.classList.add("show"));

    // Apply theme to new document before swap to prevent flash
    const savedTheme = localStorage.getItem("theme");
    const prefersDarkMode = window.matchMedia(
      "(prefers-color-scheme: dark)",
    ).matches;
    const shouldBeDark =
      savedTheme === "dark" || (savedTheme !== "light" && prefersDarkMode);
    if (shouldBeDark) {
      transitionEvent.newDocument.documentElement.classList.add("dark");
    } else {
      transitionEvent.newDocument.documentElement.classList.remove("dark");
    }

    // Apply color scheme to new document before swap to prevent flash
    const savedColorScheme = localStorage.getItem("colorScheme");
    transitionEvent.newDocument.documentElement.setAttribute(
      "data-color-scheme",
      savedColorScheme || DEFAULT_COLOR_SCHEME,
    );
  });

  // ---------------------------------------------------------------------------
  // Per-navigation setup — runs on initial load AND each navigation
  // ---------------------------------------------------------------------------

  function onPageLoad(): void {
    applyTheme(shouldBeDark());
    updateThemeButtons();
    applyColorScheme();
    updateColorSchemeButtons();
    handleScroll();
    revealAnimatedElements(isFirstLoad ? STAGGER_DELAY_MS : 0);
    isFirstLoad = false;

    closeAllSettingsPanels();
    resetMobileMenu();
    updateActiveNavLink();
    setupTypewriter();
    setupFooter();
  }

  document.addEventListener("astro:page-load", onPageLoad);

  // ---------------------------------------------------------------------------
  // Mobile menu reset
  // ---------------------------------------------------------------------------

  function resetMobileMenu(): void {
    const mobileMenu = document.getElementById("mobile-menu");
    if (mobileMenu) mobileMenu.classList.add("hidden");
    const menuOpenIcon = document.getElementById("menu-open-icon");
    const menuCloseIcon = document.getElementById("menu-close-icon");
    if (menuOpenIcon) menuOpenIcon.classList.remove("hidden");
    if (menuCloseIcon) menuCloseIcon.classList.add("hidden");
    const menuToggleButton = document.getElementById("menu-toggle");
    if (menuToggleButton) {
      menuToggleButton.setAttribute("aria-expanded", "false");
    }
  }

  // ---------------------------------------------------------------------------
  // Active nav highlighting
  // ---------------------------------------------------------------------------

  function updateActiveNavLink(): void {
    const currentPath = window.location.pathname.replace(/\/$/, "") || "/";
    const navLinks = document.querySelectorAll("header nav a");

    navLinks.forEach((navLink) => {
      const linkPath =
        (navLink.getAttribute("href") ?? "").replace(/\/$/, "") || "/";
      if (
        currentPath === linkPath ||
        (linkPath !== "/" && currentPath.startsWith(linkPath + "/"))
      ) {
        navLink.classList.add("nav-active");
      } else {
        navLink.classList.remove("nav-active");
      }
    });

    const homeNavLink = document.getElementById("nav-home");
    if (homeNavLink) {
      if (currentPath === "/") {
        homeNavLink.classList.add("nav-active");
      } else {
        homeNavLink.classList.remove("nav-active");
      }
    }
  }

  // ---------------------------------------------------------------------------
  // Typewriter greeting
  //
  // Types, pauses, deletes, and retypes greetings in different languages.
  // Each greeting gets a random color from the palette (never same twice).
  // Cursor blinks when idle, stays solid when typing/deleting.
  // ---------------------------------------------------------------------------

  function setupTypewriter(): void {
    if (typewriterTimeoutId !== null) {
      clearTimeout(typewriterTimeoutId);
      typewriterTimeoutId = null;
    }

    // Early exit if the greeting elements aren't on this page
    if (
      !document.getElementById("greeting") ||
      !document.getElementById("typewriter-cursor") ||
      !document.getElementById("greeting-wrapper")
    )
      return;

    // Re-fetch as non-nullable consts so closures below see HTMLElement, not
    // HTMLElement | null (TypeScript doesn't narrow captured variables).
    const greetingElement = document.getElementById("greeting") as HTMLElement;
    const cursorElement = document.getElementById(
      "typewriter-cursor",
    ) as HTMLElement;
    const wrapperElement = document.getElementById(
      "greeting-wrapper",
    ) as HTMLElement;

    // Skip animation entirely for users who prefer reduced motion
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) {
      greetingElement.textContent = greetings[0];
      cursorElement.classList.remove("cursor-blink");
      return;
    }

    let greetingIndex = 0;
    let characterIndex = greetings[0].length;
    let isDeleting = false;
    let activeColorIndex = 0;

    function pickNextColor(): void {
      let nextColorIndex: number;
      do {
        nextColorIndex = Math.floor(Math.random() * greetingColorCount);
      } while (nextColorIndex === activeColorIndex);
      activeColorIndex = nextColorIndex;
      wrapperElement.style.color = `var(--greeting-color-${nextColorIndex})`;
      greetingElement.style.backgroundImage = `var(--greeting-grad-${nextColorIndex})`;
    }

    function typewriterTick(): void {
      const currentGreeting = greetings[greetingIndex];
      cursorElement.classList.add("cursor-typing");

      if (isDeleting) {
        characterIndex--;
        greetingElement.textContent = currentGreeting.substring(
          0,
          characterIndex,
        );

        if (characterIndex === 0) {
          isDeleting = false;
          greetingIndex = (greetingIndex + 1) % greetings.length;
          pickNextColor();
          typewriterTimeoutId = window.setTimeout(
            typewriterTick,
            TYPEWRITER_PAUSE_AFTER_DELETE_MS,
          );
        } else {
          typewriterTimeoutId = window.setTimeout(
            typewriterTick,
            TYPEWRITER_DELETE_SPEED_MS,
          );
        }
      } else {
        characterIndex++;
        greetingElement.textContent = greetings[greetingIndex].substring(
          0,
          characterIndex,
        );

        if (characterIndex === greetings[greetingIndex].length) {
          cursorElement.classList.remove("cursor-typing");
          typewriterTimeoutId = window.setTimeout(() => {
            isDeleting = true;
            typewriterTick();
          }, TYPEWRITER_PAUSE_BEFORE_DELETE_MS);
        } else {
          typewriterTimeoutId = window.setTimeout(
            typewriterTick,
            TYPEWRITER_TYPE_SPEED_MS,
          );
        }
      }
    }

    // Start with first greeting visible, cursor blinking. After pause, cycle.
    typewriterTimeoutId = window.setTimeout(() => {
      isDeleting = true;
      typewriterTick();
    }, TYPEWRITER_PAUSE_BEFORE_DELETE_MS);
  }

  // ---------------------------------------------------------------------------
  // Footer — dynamic year
  // ---------------------------------------------------------------------------

  function setupFooter(): void {
    const footerYearElement = document.getElementById("footer-year");
    if (footerYearElement) {
      footerYearElement.textContent = new Date().getFullYear().toString();
    }
  }

  // ---------------------------------------------------------------------------
  // Stagger animation — reveals .animate elements sequentially on first load
  // ---------------------------------------------------------------------------

  function revealAnimatedElements(delayBetweenMs: number): void {
    const animatedElements = document.querySelectorAll(".animate");

    animatedElements.forEach((element, index) => {
      if (delayBetweenMs > 0) {
        setTimeout(() => {
          element.classList.add("show");
        }, index * delayBetweenMs);
      } else {
        element.classList.add("show");
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Scroll state
  // ---------------------------------------------------------------------------

  function handleScroll(): void {
    if (window.scrollY > 0) {
      document.documentElement.classList.add("scrolled");
    } else {
      document.documentElement.classList.remove("scrolled");
    }

    const backToTopButton = document.getElementById("back-to-top");
    if (backToTopButton) {
      const shouldShow = window.scrollY > window.innerHeight / 2;
      backToTopButton.classList.toggle("opacity-0", !shouldShow);
      backToTopButton.classList.toggle("pointer-events-none", !shouldShow);
      backToTopButton.classList.toggle("opacity-60", shouldShow);
      backToTopButton.classList.toggle("pointer-events-auto", shouldShow);
    }
  }

  // ---------------------------------------------------------------------------
  // Theme
  // ---------------------------------------------------------------------------

  function shouldBeDark(): boolean {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme === "light") return false;
    if (savedTheme === "dark") return true;
    return window.matchMedia("(prefers-color-scheme: dark)").matches;
  }

  function applyTheme(dark: boolean): void {
    // Temporarily disable transitions to prevent flash during theme switch
    const transitionBlocker = document.createElement("style");
    transitionBlocker.appendChild(
      document.createTextNode(
        "* {" +
          "-webkit-transition: none !important;" +
          "-moz-transition: none !important;" +
          "-o-transition: none !important;" +
          "-ms-transition: none !important;" +
          "transition: none !important;" +
          "}",
      ),
    );
    document.head.appendChild(transitionBlocker);

    document.documentElement.classList.toggle("dark", dark);

    // Force reflow so the transition blocker takes effect before removal
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    window.getComputedStyle(transitionBlocker).opacity;
    document.head.removeChild(transitionBlocker);
  }

  function updateThemeButtons(): void {
    const activeTheme = localStorage.getItem("theme") ?? "system";
    const themeButtons = document.querySelectorAll("[data-theme-button]");
    themeButtons.forEach((button) => {
      const isActive =
        (button as HTMLElement).dataset.themeButton === activeTheme;
      button.setAttribute("aria-pressed", isActive ? "true" : "false");
      if (isActive) {
        button.classList.add("theme-active");
      } else {
        button.classList.remove("theme-active");
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Settings panel
  // ---------------------------------------------------------------------------

  function closeAllSettingsPanels(): void {
    document.querySelectorAll("[data-settings-panel]").forEach((panel) => {
      panel.classList.add("hidden");
    });
    document.querySelectorAll("[data-settings-trigger]").forEach((trigger) => {
      trigger.setAttribute("aria-expanded", "false");
    });
  }

  // ---------------------------------------------------------------------------
  // Color Scheme
  // ---------------------------------------------------------------------------

  function applyColorScheme(): void {
    const savedScheme = localStorage.getItem("colorScheme");
    let effectiveScheme = savedScheme || DEFAULT_COLOR_SCHEME;

    // Validate saved scheme against available scheme buttons in the DOM
    const schemeButtons = document.querySelectorAll("[data-scheme-button]");
    if (schemeButtons.length > 0) {
      let isValidScheme = false;
      schemeButtons.forEach((button) => {
        if ((button as HTMLElement).dataset.schemeButton === savedScheme) {
          isValidScheme = true;
        }
      });

      if (!isValidScheme) {
        effectiveScheme = DEFAULT_COLOR_SCHEME;
        localStorage.setItem("colorScheme", effectiveScheme);
      }
    }

    document.documentElement.setAttribute("data-color-scheme", effectiveScheme);
  }

  function updateColorSchemeButtons(): void {
    const activeScheme =
      localStorage.getItem("colorScheme") || DEFAULT_COLOR_SCHEME;
    const schemeButtons = document.querySelectorAll("[data-scheme-button]");
    schemeButtons.forEach((button) => {
      const isActive =
        (button as HTMLElement).dataset.schemeButton === activeScheme;
      button.setAttribute("aria-pressed", isActive ? "true" : "false");
      if (isActive) {
        button.classList.add("scheme-active");
      } else {
        button.classList.remove("scheme-active");
      }
    });
  }
</script>
