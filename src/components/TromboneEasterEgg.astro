---
// TromboneEasterEgg.astro
// Easter egg: click portrait 5 times to play "The Lick" on trombone + trigger confetti
// The Lick: D E F G E C D (https://en.wikipedia.org/wiki/The_Lick)
---

<script>
  import Soundfont from "soundfont-player";
  import type { Player } from "soundfont-player";

  // Constants
  const CLICK_RESET_TIMEOUT_MS = 5000;
  const SINGLE_NOTE_DURATION_S = 0.3;
  const RIFF_NOTE_DURATION_S = 0.15;
  const RIFF_NOTE_GAP_MS = 50;
  const CONFETTI_PARTICLE_COUNT = 70;
  const CONFETTI_ANIMATION_DURATION_MS = 3000;
  const CONFETTI_BURST_VELOCITY_MIN = 8;
  const CONFETTI_BURST_VELOCITY_MAX = 15;
  const CONFETTI_GRAVITY = 0.4;
  const CONFETTI_HORIZONTAL_DRIFT_MAX = 3;
  const CLICKS_TO_TRIGGER_RIFF = 5;

  // "The Lick" in D minor: D4 E4 F4 G4 E4 C4 D4
  // Clicks 1-4 play the first four notes individually; click 5 plays the full lick
  const LICK_CLICK_NOTES = ["D4", "E4", "F4", "G4"];
  const LICK_FULL_NOTES = ["D4", "E4", "F4", "G4", "E4", "C4", "D4"];

  interface ConfettiParticle {
    element: HTMLDivElement;
    x: number;
    y: number;
    velocityX: number;
    velocityY: number;
    rotation: number;
    rotationVelocity: number;
  }

  // Fallback colors used if theme CSS variables are missing or empty,
  // to ensure confetti particles are always visible.
  const FALLBACK_CONFETTI_COLORS = [
    "#EF4444",
    "#F97316",
    "#EAB308",
    "#22C55E",
    "#06B6D4",
    "#3B82F6",
  ];

  let clickCount = 0;
  let resetTimer: number | null = null;
  let audioContext: AudioContext | null = null;
  let trombonePlayer: Player | null = null;
  let isLoadingInstrument = false;
  let isRiffPlaying = false;
  let activeConfettiParticles: ConfettiParticle[] = [];
  let activeRiffTimeouts: number[] = [];
  let isClickListenerRegistered = false;

  function getAudioContext(): AudioContext {
    if (audioContext === null) {
      audioContext = new (
        window.AudioContext ||
        (window as unknown as { webkitAudioContext: typeof AudioContext })
          .webkitAudioContext
      )();
    }
    return audioContext;
  }

  async function loadTromboneIfNeeded(): Promise<Player | null> {
    if (trombonePlayer !== null) return trombonePlayer;
    if (isLoadingInstrument) return null;

    isLoadingInstrument = true;
    try {
      trombonePlayer = await Soundfont.instrument(
        getAudioContext(),
        "trombone",
      );
      return trombonePlayer;
    } catch {
      // Silently fail â€” the easter egg just won't play sound
      return null;
    } finally {
      isLoadingInstrument = false;
    }
  }

  async function playTromboneNote(noteName: string): Promise<void> {
    const player = await loadTromboneIfNeeded();
    if (player === null) return;

    player.play(noteName, getAudioContext().currentTime, {
      duration: SINGLE_NOTE_DURATION_S,
    });
  }

  async function playRiff(): Promise<void> {
    const player = await loadTromboneIfNeeded();
    if (player === null) return;

    // Clear any existing riff timeouts
    activeRiffTimeouts.forEach((timeoutId) => clearTimeout(timeoutId));
    activeRiffTimeouts = [];

    const context = getAudioContext();

    LICK_FULL_NOTES.forEach((noteName, index) => {
      const timeoutId = window.setTimeout(
        () => {
          player.play(noteName, context.currentTime, {
            duration: RIFF_NOTE_DURATION_S,
          });
        },
        index * (RIFF_NOTE_DURATION_S * 1000 + RIFF_NOTE_GAP_MS),
      );
      activeRiffTimeouts.push(timeoutId);
    });
  }

  function getThemeColors(): string[] {
    const style = getComputedStyle(document.documentElement);
    const isDark = document.documentElement.classList.contains("dark");

    const colorKeys = [
      "accent",
      "warm",
      "green",
      "orange",
      "red",
      "cyan",
      "yellow",
    ];

    const colors = colorKeys
      .map((key) => {
        const cssVarName = `--color-tn-${isDark ? "dark" : "light"}-${key}`;
        return style.getPropertyValue(cssVarName).trim();
      })
      .filter((color) => color !== "");

    if (colors.length > 0) {
      return colors;
    }

    return FALLBACK_CONFETTI_COLORS;
  }

  function createConfetti(portraitElement: HTMLElement): void {
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) return;

    const colors = getThemeColors();
    const rect = portraitElement.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Clear any existing confetti particles
    cleanupConfetti();

    const particles: ConfettiParticle[] = [];
    activeConfettiParticles = particles;

    for (
      let particleIndex = 0;
      particleIndex < CONFETTI_PARTICLE_COUNT;
      particleIndex++
    ) {
      const particle = document.createElement("div");
      particle.style.position = "fixed";
      particle.style.width = "8px";
      particle.style.height = "8px";
      particle.style.backgroundColor =
        colors[Math.floor(Math.random() * colors.length)];
      particle.style.pointerEvents = "none";
      particle.style.zIndex = "9999";
      particle.style.borderRadius = Math.random() > 0.5 ? "50%" : "0";
      document.body.appendChild(particle);

      const angle = (Math.PI * 2 * particleIndex) / CONFETTI_PARTICLE_COUNT;
      const velocity =
        CONFETTI_BURST_VELOCITY_MIN +
        Math.random() *
          (CONFETTI_BURST_VELOCITY_MAX - CONFETTI_BURST_VELOCITY_MIN);

      particles.push({
        element: particle,
        x: centerX,
        y: centerY,
        velocityX: Math.cos(angle) * velocity,
        velocityY: Math.sin(angle) * velocity - velocity * 0.3,
        rotation: Math.random() * 360,
        rotationVelocity: (Math.random() - 0.5) * 10,
      });
    }

    const startTime = Date.now();

    function animate(): void {
      const elapsed = Date.now() - startTime;

      if (elapsed > CONFETTI_ANIMATION_DURATION_MS) {
        particles.forEach((particle) => particle.element.remove());
        activeConfettiParticles = [];
        // Reset riff-playing lock and click count when confetti finishes
        isRiffPlaying = false;
        clickCount = 0;
        return;
      }

      particles.forEach((particle) => {
        particle.velocityY += CONFETTI_GRAVITY;
        particle.velocityX +=
          (Math.random() - 0.5) * CONFETTI_HORIZONTAL_DRIFT_MAX * 0.1;
        particle.x += particle.velocityX;
        particle.y += particle.velocityY;
        particle.rotation += particle.rotationVelocity;

        particle.element.style.left = `${particle.x}px`;
        particle.element.style.top = `${particle.y}px`;
        particle.element.style.transform = `rotate(${particle.rotation}deg)`;
      });

      requestAnimationFrame(animate);
    }

    animate();
  }

  function cleanupConfetti(): void {
    activeConfettiParticles.forEach((particle) => particle.element.remove());
    activeConfettiParticles = [];
  }

  function addPortraitBounce(portraitElement: HTMLElement): void {
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) return;

    const keyframes = [
      { transform: "scale(1)" },
      { transform: "scale(1.05)" },
      { transform: "scale(1)" },
    ];

    portraitElement.animate(keyframes, {
      duration: 200,
      easing: "ease-out",
    });
  }

  function addPortraitShake(portraitElement: HTMLElement): void {
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) return;

    const keyframes = [
      { transform: "rotate(0deg) scale(1)" },
      { transform: "rotate(-5deg) scale(1.08)" },
      { transform: "rotate(5deg) scale(1.08)" },
      { transform: "rotate(-5deg) scale(1.08)" },
      { transform: "rotate(5deg) scale(1.08)" },
      { transform: "rotate(0deg) scale(1)" },
    ];

    portraitElement.animate(keyframes, {
      duration: 500,
      easing: "ease-in-out",
    });
  }

  function handlePortraitClick(event: Event): void {
    // Block all clicks while the riff + confetti sequence is playing
    if (isRiffPlaying) return;

    const target = (event.target as HTMLElement).closest(
      "[data-easter-egg-target]",
    );
    if (!target) return;

    clickCount++;

    if (resetTimer !== null) {
      clearTimeout(resetTimer);
    }

    resetTimer = window.setTimeout(() => {
      clickCount = 0;
      resetTimer = null;
    }, CLICK_RESET_TIMEOUT_MS);

    if (clickCount < CLICKS_TO_TRIGGER_RIFF) {
      void playTromboneNote(LICK_CLICK_NOTES[clickCount - 1]);
      addPortraitBounce(target as HTMLElement);
    } else if (clickCount === CLICKS_TO_TRIGGER_RIFF) {
      // Lock out further clicks until confetti finishes
      isRiffPlaying = true;
      if (resetTimer !== null) {
        clearTimeout(resetTimer);
        resetTimer = null;
      }

      void playRiff();
      createConfetti(target as HTMLElement);
      addPortraitShake(target as HTMLElement);
    }
  }

  function resetState(): void {
    clickCount = 0;
    isRiffPlaying = false;
    if (resetTimer !== null) {
      clearTimeout(resetTimer);
      resetTimer = null;
    }
  }

  function cleanup(): void {
    resetState();
    cleanupConfetti();
    activeRiffTimeouts.forEach((timeoutId) => clearTimeout(timeoutId));
    activeRiffTimeouts = [];
  }

  function initialize(): void {
    const portraitElement = document.querySelector("[data-easter-egg-target]");
    if (!portraitElement) return;

    // Reset state on each navigation
    resetState();

    // Register click listener only once
    if (!isClickListenerRegistered) {
      document.addEventListener("click", handlePortraitClick);
      isClickListenerRegistered = true;
    }
  }

  // Initialize on page load and on View Transitions navigation
  document.addEventListener("astro:page-load", initialize);

  // Clean up before navigating to a new page
  document.addEventListener("astro:before-swap", cleanup);
</script>
